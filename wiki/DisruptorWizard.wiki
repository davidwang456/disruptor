#summary How to use the Disruptor DSL to simplify setting up the ring buffer.

= Introduction =

The Disruptor class provides a simple DSL-style API to make it simpler to setup event handlers and express the dependencies between them.

== Parallel Event Handlers ==

First create the wizard with the desired configuration for the ring buffer:

{{{
Disruptor<ValueEvent> disruptor =
  new Disruptor<ValueEvent>(ValueEntry.EVENT_FACTORY, RING_SIZE, EXECUTOR,
                                 ClaimStrategy.Option.SINGLE_THREADED,
                                 WaitStrategy.Option.YIELDING);
}}}

Note that we pass in an Executor instance which will be used to execute the event handlers in their own thread.

Then we add the event handlers which will process events in parallel:

{{{
disruptor.handleEventsWith(handler1, handler2, handler3, handler4);
}}}

And finally start the event handler threads and retrieve the configured !RingBuffer:

{{{
RingBuffer<ValueEvent> ringBuffer = disruptor.start();
}}}

Producers can then use the !RingBuffer's nextEvent and publish functions as normal to add events to the ring buffer.

== Dependencies ==

Dependencies between handlers can be expressed in the Disruptor by chaining them together, for example:

{{{disruptor.handleEventsWith(handler1).then(handler2, handler3, handler4);}}}

In this case handler 1 must process events first, with handler 2, 3 and 4 processing them in parallel after that.  Dependency chains can also be created, so to ensure each handler processes events in sequence:

{{{disruptor.handleEventsWith(handler1).then(handler2).then(handler3).then(handler4);}}}

Multiple chains can also be created:

{{{
disruptor.handleEventsWith(handler1).then(handler2);
disruptor.handleEventsWith(handler3).then(handler4);
}}}